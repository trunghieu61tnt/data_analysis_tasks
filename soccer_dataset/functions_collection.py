# -*- coding: utf-8 -*-
"""
From european_soccer_processing.ipynb

Automatically generated by Colaboratory.
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder
import matplotlib.pyplot as plt
import seaborn as sns

class LeagueInfo:
    # get the number of matches per round
    def matches_per_round(self, frame, division, season):
        n = frame.loc[division].loc[season]['No of Teams']
        n = int(n / 2)
        return n

    # get the number of rounds of league
    def max_round(self, frame, division, season):
        n = self.matches_per_round(frame, division, season)
        m = frame.loc[division].loc[season]['No of Matches']
        num = int(np.ceil(m / n))
        return num

class MatchShow(LeagueInfo):
    # retrieve all match results in a given time range
    def matches_between(self, frame, division, begin, end):
        # string to datetime
        begin = pd.to_datetime(begin)
        end = pd.to_datetime(end)
        # query frame by parameters and do some manipulations
        frame = frame.query('Div == @division and Date >= @begin and Date <= @end').copy(deep=True)
        frame.drop(['Div'], axis=1, inplace=True) # don't need this column 'cause the context is known
        frame.sort_values(by=['Date'], inplace=True)
        return frame
    # retrieve all match results in a given round
    def matches_in_round(self, frame1, frame2, division, season, round):
        # query frame by parameters and do some manipulations
        frame = frame1.query('Div == @division').copy(deep=True)
        frame = frame[frame['season']==season]
        frame.drop(['Div'], axis=1, inplace=True)
        frame.sort_values(by=['Date'], inplace=True)
        # query by round
        n = self.matches_per_round(frame2, division, season)
        begin = n * (round - 1)
        end = n * round
        try:
            x = frame.iloc[begin:end]
        except TypeError:
            return 'Invalid Round!'
        else:
            frame = frame.iloc[begin:end]
            return frame

    # retrieve all match results after a given round
    def matches_after_round(self, frame1, frame2, division, season, round):
        # query frame by parameters and do some manipulations
        frame = frame1.query('Div == @division').copy(deep=True)
        frame = frame[frame['season']==season]
        frame.drop(['Div', 'season'], axis=1, inplace=True)
        frame.sort_values(by=['Date'], inplace=True)
        # query by round
        n = self.matches_per_round(frame2, division, season)
        end = n * round
        try:
            frame.iloc[:end]
        except TypeError:
            return 'Invalid Round!'
        else:
            frame = frame.iloc[:end]
        return frame

class ResultShow(MatchShow):
    # create one hot frame for result column
    def result_onehot(self, frame):
        onehot = OneHotEncoder(sparse_output=False)
        # get the categorical column in suitable form
        ftr = frame['FTR'].tolist()
        ftr = np.array(ftr)
        ftr = ftr.reshape(len(ftr), 1)
        # apply
        onehot = onehot.fit(ftr)
        columns = onehot.categories_
        onehot = onehot.fit_transform(ftr)
        output = pd.DataFrame(onehot, index=frame['FTR'].index, columns=columns)
        return output

    # convert a frame of matches to result table
    def matches_to_table(self, frame):
        '''
        each match affects 2 teams
        each point in FTHG is a goal for home team and obviously a goal aganst home team
        FTAG is similar
        H in FTR means home team is the winner, A for away team
        '''
        # home frame for home team
        home = frame[['HomeTeam', 'FTHG', 'FTAG', 'FTR']].copy(deep=True)
        home.rename(columns={'HomeTeam': 'Team', 'FTHG': 'GF', 'FTAG': 'GA'}, inplace=True)
        # away frame for away team
        away = frame[['AwayTeam', 'FTAG', 'FTHG', 'FTR']].copy(deep=True)
        away.rename(columns={'AwayTeam': 'Team', 'FTAG': 'GF', 'FTHG': 'GA'}, inplace=True)
        away['FTR'].replace({'H': 'A', 'A': 'H'}, inplace=True)

        output = pd.concat([home, away], ignore_index=True)
        result = self.result_onehot(output) # retrieve 3 new columns from original FTR
        if result.shape[1] != 3:
            full_columns = [('A',), ('D',), ('H,')]
            for c in full_columns:
                if c not in result.columns:
                    result[c] = 0
        output = pd.concat([output, result], axis=1) # expand frame
        # group all stats for each team
        output1 = output.drop('FTR', axis=1)
        output1 = output1.groupby('Team').sum()
        # get the number of matchs of each team
        output2 = output.groupby('Team')['GF'].count()
        # merge columns in one stats table and manipulate the output
        output = pd.merge(output2, output1, how='inner', left_index=True, right_index=True)
        output.rename(columns={'GF_x': 'Played', 'GF_y': 'GF', ('A',): 'Lost', ('D',): 'Drawn', ('H',): 'Won'}, inplace=True)
        output = output[['Played', 'Won', 'Drawn', 'Lost', 'GF', 'GA']]
        return output

    # retrieve team results in a given time range
    def league_result_between(self, frame, division, begin, end):
        frame = self.matches_between(frame, division, begin, end)
        frame = self.matches_to_table(frame)
        return frame

    # retrieve team results after a given round
    def league_result_after_round(self, frame1, frame2, division, season, round):
        frame = self.matches_after_round(frame1, frame2, division, season, round)
        if isinstance(frame, str):
            n = 2 # pass
        else:
            frame = self.matches_to_table(frame)
            # expand frame
            frame['GD'] = frame['GF'] - frame['GA']
            frame['Points'] = frame['Won'] * 3 + frame['Drawn']
            # sorting
            frame.sort_values(by=['Points', 'GD', 'Team'], ascending=False, inplace=True)
            frame.reset_index(drop=False, inplace=True)
            frame['Rank'] = frame.index + 1
            frame.set_index('Team', inplace=True)
        return frame

    def league_result_season(self, frame1, frame2, division, season):
        round = self.max_round(frame2, division, season)
        frame = self.league_result_after_round(frame1, frame2, division, season, round)
        return frame

class Performance(ResultShow):
    # ranking variation of a team in given season
    def team_performance(self, frame1, frame2, team, season):
        # calculate
        division = frame1.query('HomeTeam == @team').iloc[0]['Div']
        maxround = self.max_round(frame2, division, season)
        # query values
        ranks = []
        for i in range(maxround):
            round = i + 1
            rank = self.league_result_after_round(frame1, frame2, division, season, round).loc[team]['Rank'].copy()
            ranks.append(rank)
        data = {'Round': list(range(maxround)), 'Rank': ranks}
        frame = pd.DataFrame(data)
        frame['Round'] += 1
        frame.sort_values(by=['Round'], inplace=True)
        frame.set_index('Round', inplace=True)
        return frame

    # plot the right above function
    def team_performance_plot(self, frame1, frame2, team, season):
        frame = self.team_performance(frame1, frame2, team, season)
        fig, ax = plt.subplots(figsize=(12, 4))
        ax = sns.lineplot(frame, legend=False)
        ax.invert_yaxis()
        plt.show()

    # check the relation between 2 given teams
    def dual_teams_check(self, frame, team_1, team_2):
        df1 = frame.query('HomeTeam == @team_1 and AwayTeam == @team_2')
        # if 2 teams are in the same league, return True
        if df1.shape[0] == 0:
            return False
        else:
            return True

    # check the relation among given teams
    def teams_check(self, frame, teams):
        for team in teams[1:]:
            check = self.dual_teams_check(frame, teams[0], team)
            if not check:
                return False
            else:
                continue
        return True

    # compare ranking variations of teams in the same league
    def team_performance_compare(self, frame1, frame2, teams, season):
        check = self.teams_check(frame1, teams)
        if not check:
            msg = 'Choose Other Teams!'
            return msg
        else:
            sample = teams[0]
            division = frame1.query('HomeTeam == @sample').iloc[0]['Div']
            maxround = self.max_round(frame2, division, season)
            # query values
            ranks = []
            for i in range(maxround):
                round = i + 1
                try:
                    x = self.league_result_after_round(frame1, frame2, division, season, round).loc[teams]['Rank'].to_list()
                except KeyError:
                    return 'Choose Another Season!'
                else:
                    rank = self.league_result_after_round(frame1, frame2, division, season, round).loc[teams]['Rank'].to_list()
                ranks.append(rank)
            ranks = np.array(ranks)
            # collect data
            data = {'Round': list(range(maxround))}
            for i in range(len(teams)):
                data[f'{teams[i]}'] = ranks[:, i]
            # edit frame
            frame = pd.DataFrame(data)
            frame['Round'] += 1
            frame.sort_values(by=['Round'], inplace=True)
            frame.set_index('Round', inplace=True)
            return frame

    # plot the right above function
    def team_performance_compare_plot(self, frame1, frame2, teams, season):
        frame = self.team_performance_compare(frame1, frame2, teams, season)
        if isinstance(frame, str):
            return 'Choose Other Teams or Season!'
        else:
            fig, ax = plt.subplots(figsize=(12, 4))
            ax = sns.lineplot(frame)
            ax.invert_yaxis()
            plt.show()

class HeadToHead(Performance):

    # head-to-head statistics between 2 given teams
    def head_to_head(self, frame, team_1, team_2):
        check = self.dual_teams_check(frame, team_1, team_2)
        if not check:
            msg = 'Choose Another Teams!'
            return msg
        else:
            # create data sheet
            stats = ['Matches', 'Won', 'Drawn', 'Goals', 'Clean Sheets']
            team_1_stats = [0] * 5
            team_2_stats = [0] * 5
            # get related records
            df1 = frame.query('HomeTeam == @team_1 and AwayTeam == @team_2')
            df2 = frame.query('HomeTeam == @team_2 and AwayTeam == @team_1')
            # fill the sheet
            # Matches
            num = df1.shape[0] +  df2.shape[0]
            team_1_stats[0] = num
            team_2_stats[0] = num
            #results
            team_1_stats[1] = df1.query('FTR == "H"').shape[0] + df2.query('FTR == "A"').shape[0]
            team_1_stats[2] = df1.query('FTR == "D"').shape[0] + df2.query('FTR == "D"').shape[0]
            team_2_stats[2] = team_1_stats[2]
            team_2_stats[1] = team_2_stats[0] - team_2_stats[2] - team_1_stats[1]
            # goals
            team_1_stats[3] = df1['FTHG'].sum() + df2['FTAG'].sum()
            team_2_stats[3] = df1['FTAG'].sum() + df2['FTHG'].sum()
            # clean sheets
            team_1_stats[4] = df1.query('FTAG == 0').shape[0] + df2.query('FTHG == 0').shape[0]
            team_2_stats[4] = df1.query('FTHG == 0').shape[0] + df2.query('FTAG == 0').shape[0]
            # edit output
            data = {'stats': stats, f'{team_1}': team_1_stats, f'{team_2}': team_2_stats}
            frame = pd.DataFrame(data)
            frame = frame.iloc[:, [1, 0, 2]]
            return frame